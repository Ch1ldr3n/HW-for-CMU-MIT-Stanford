## README

datalab-handout.tar 是原文件，大家可以下载下来自己实现。

datalab-handout文件夹是我的实现结果


1.I need to remove the -m32 flag in the Makefile in order to compile.

### bitXor
a^b=(a&~b)|(~a&b)=~(~(a&~b)&~(~a&b))

### tmin

tmin=0X80000000

### isTmax
其实我们可以很快的发现在计算机里面$T_{max}+1+T_{max}=-1$，也就是说$2T_{max}+1=T_{min}$但是很不凑巧的是$2*(-1)+1=-1$,所以我们为了运用$2T_{max}+1=-1$这个性质的时候必须要把$-1$排除。
但是由于$-1+1=0$但是$T_{max}+1=T_{min}$,所以可以根据这个性质将两者区分开。

### allOddBits
思路：比较直接，我们8个一组取出来，先&在^就很容易解决了。

### negate
应该是最简单的一道题目了，直接运用公式就可以了。

### isAsciiDigit
0-3位用卡诺图
4-7必须为3
剩下全为0

这里一定要分清楚逻辑运算和位运算

### conditional

将x转换为0，1用!!，这很重要

### isLessOrEqual

1.不同号
比较符号位
2.同号的情况
相等？->异或
不想等->**限制符号相同**(容易遗忘)并且相减看符号是什么

### logicalNeg

不断的把高位上面的1往下面移动就可以了。

### howManyBits

1个bit可以表示-1~0
2个bit可以表示-2~1
3个bit可以表示-4~3

先转成正数然后跟上一题一样不断的把高位的1移动下来。

### float_twice

### float_i2f

由于浮点数的表示中对于负数并没有使用补码的方式，正负号完全取决于符号位，所以对于负数输入，我们需要做的第一步工作就是把它取负为正数再进行后面的操作。在这个过程我们需要记录下正负，在之后的操作中需要使用。

由于浮点数与整数表示的不同，浮点数的有效数字的位置在第0-22位的23位中，并且第一个1在规格化表示中会被省略，我们只需要第一个1以后的位数，并且我们需要知道在浮点数表示中它的指数应该为多少，所以在这个过程中我们同时需要记录第一个1出现的位置并以此决定指数。

在代码中使用了一个i来记录左移的位数，也就是最高位的1之前的零的个数，那么32-i就是最后的指数。

在循环中我们将整数的有效数字提前到了最前，然后将最高位移出， 这时我们用temp保存这时的状态。供之后的舍入判断使用。

接下来，我们需要将有效位移到正确的位置上，也就是向右位移9位。

下面按照之前的记录把符号位置上正确的值。

现在已经处理好有效数字与符号部分，下面要做的就是处理指数部分。

之前说过32-i是指数的数值，注意我们需要将这个值加上偏移量127，再放入表示指数的位置中。

下面就要处理舍入的情况了，浮点数表示的舍入规则比较特殊，也是本题的难点。结合本题的情况进行介绍：

在右移之前我们保存了这时的状态，因为当右移九位后原来的低九位如果有数据就会被舍弃，我们就需要根据舍弃的这九位与未被舍弃的最后一位（也就是原数第9位，下称第9位）来判断舍入的情况。

如果舍弃的这九位的最高位为0，那么说明舍去的数值小于保留下来的最低位表示的值的二分之一，那么我们不需要舍入。

如果舍弃的这九位的最高位为1，并且后面的位有数值，那么说明舍去的数值大于第9位表示的值的二分之一，这个时候我们需要舍入，也就是把最终结果加一。

如果舍弃的这九位的最高位为1，并且后面的位都是0，这个时候正好就是第9位表示的值的二分之一。那么这个时候我们就要看第9位，如果第9位为0，那么不舍入。如果第9位为1，那么进行舍入，也就是把最终结果加一。

### float_f2i

注意指数部分大于22和小于22的情况。